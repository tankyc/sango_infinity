//this source code was auto-generated by tolua#, do not modify it
using System;
using LuaInterface;

public class Sango_UtilityWrap
{
	public static void Register(LuaState L)
	{
		L.BeginStaticLibs("Utility");
		L.RegFunction("GetBytes", new LuaCSFunction(GetBytes));
		L.RegFunction("GetFloat", new LuaCSFunction(GetFloat));
		L.RegFunction("GetShort", new LuaCSFunction(GetShort));
		L.RegFunction("GetInt", new LuaCSFunction(GetInt));
		L.RegFunction("GetLong", new LuaCSFunction(GetLong));
		L.RegFunction("MD5Encrypt", new LuaCSFunction(MD5Encrypt));
		L.RegFunction("GetMD5HashFromFile", new LuaCSFunction(GetMD5HashFromFile));
		L.RegFunction("Encrypt_128_ECB", new LuaCSFunction(Encrypt_128_ECB));
		L.EndStaticLibs();
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetBytes(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 2 && TypeChecker.CheckTypes<float, bool>(L, 1))
			{
				float arg0 = (float)LuaDLL.lua_tonumber(L, 1);
				bool arg1 = LuaDLL.lua_toboolean(L, 2);
				byte[] o = Sango.Utility.GetBytes(arg0, arg1);
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 2 && TypeChecker.CheckTypes<long, bool>(L, 1))
			{
				long arg0 = LuaDLL.tolua_toint64(L, 1);
				bool arg1 = LuaDLL.lua_toboolean(L, 2);
				byte[] o = Sango.Utility.GetBytes(arg0, arg1);
				ToLua.Push(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: Sango.Utility.GetBytes");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetFloat(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			byte[] arg0 = ToLua.CheckByteBuffer(L, 1);
			bool arg1 = LuaDLL.luaL_checkboolean(L, 2);
			float o = Sango.Utility.GetFloat(arg0, arg1);
			LuaDLL.lua_pushnumber(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetShort(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			byte[] arg0 = ToLua.CheckByteBuffer(L, 1);
			bool arg1 = LuaDLL.luaL_checkboolean(L, 2);
			short o = Sango.Utility.GetShort(arg0, arg1);
			LuaDLL.lua_pushinteger(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetInt(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			byte[] arg0 = ToLua.CheckByteBuffer(L, 1);
			bool arg1 = LuaDLL.luaL_checkboolean(L, 2);
			int o = Sango.Utility.GetInt(arg0, arg1);
			LuaDLL.lua_pushinteger(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetLong(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			byte[] arg0 = ToLua.CheckByteBuffer(L, 1);
			bool arg1 = LuaDLL.luaL_checkboolean(L, 2);
			long o = Sango.Utility.GetLong(arg0, arg1);
			LuaDLL.tolua_pushint64(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int MD5Encrypt(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			string arg0 = ToLua.CheckString(L, 1);
			string o = Sango.Utility.MD5Encrypt(arg0);
			LuaDLL.lua_pushstring(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int GetMD5HashFromFile(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			string arg0 = ToLua.CheckString(L, 1);
			string o = Sango.Utility.GetMD5HashFromFile(arg0);
			LuaDLL.lua_pushstring(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int Encrypt_128_ECB(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 1)
			{
				string arg0 = ToLua.CheckString(L, 1);
				string o = Sango.Utility.Encrypt_128_ECB(arg0);
				LuaDLL.lua_pushstring(L, o);
				return 1;
			}
			else if (count == 2)
			{
				string arg0 = ToLua.CheckString(L, 1);
				byte[] arg1 = ToLua.CheckByteBuffer(L, 2);
				string o = Sango.Utility.Encrypt_128_ECB(arg0, arg1);
				LuaDLL.lua_pushstring(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: Sango.Utility.Encrypt_128_ECB");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}
}

